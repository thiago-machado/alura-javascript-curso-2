{"version":3,"sources":["../../app-es6/helpers/Bind.js"],"names":["Bind","model","view","props","proxy","ProxyFactory","create","update"],"mappings":";;;;AAAA;;;;;;;;IAQMA,I;;AAEJ;;;;;;AAMA,cAAYC,KAAZ,EAAmBC,IAAnB,EAAmC;AAAA;;AAAA,oCAAPC,KAAO;AAAPA,SAAO;AAAA;;AAEjC;;;;;;AAMA,MAAIC,QAAQC,aAAaC,MAAb,CAAoBL,KAApB,EAA2BE,KAA3B,EAAkC;AAAA,WAASD,KAAKK,MAAL,CAAYN,KAAZ,CAAT;AAAA,GAAlC,CAAZ;;AAEAC,OAAKK,MAAL,CAAYN,KAAZ,EAViC,CAUb;AACpB,SAAOG,KAAP,CAXiC,CAWnB;AACf,C","file":"Bind.js","sourcesContent":["/*\r\n Quando criamos um Proxy da _listaNegociacoes e _mensagem, nosso objetivo é\r\n realizar um Data binding (que traduzido para o português, significa \"ligação de dados\").\r\n\r\n Nós queremos fazer uma associação entre o modelo e a View, ou seja, sempre que\r\n alterarmos o modelo, queremos disparar a atualização da View.\r\n Damos o nome disso de Data binding unidirecional.\r\n*/\r\nclass Bind {\r\n\r\n  /*\r\n  ProxyFactory precisa receber um array, por isso, as propriedades eram passadas\r\n  entre [] (colchetes).\r\n  Contudo, quando o último parâmetro de um construtor, função ou método é\r\n  variável, podemos usar o parâmetro REST operator (...).\r\n  */\r\n  constructor(model, view, ...props) {\r\n\r\n    /*\r\n    Criando um proxy com base no modelo (model) recebido como parâmetro.\r\n    Esse modelo pode ser uma instância de ListaNegociacoes, ou Mensagem.\r\n    A view nada mais é do que a classe que cuida da atualização da interface.\r\n    As props são os atirbutos/funções que desejamos interceptar no proxy.\r\n    */\r\n    let proxy = ProxyFactory.create(model, props, model => view.update(model));\r\n\r\n    view.update(model); // Realiza a primeira atualização mesmo sem ainda existir dados.\r\n    return proxy; // O construtor pode retornar um valor\r\n  }\r\n}\r\n"]}