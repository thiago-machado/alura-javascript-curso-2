{"version":3,"sources":["../../app-es6/services/NegociacaoService.js"],"names":["NegociacaoService","_http","HttpService","Promise","resolve","reject","get","then","negociacoes","map","Negociacao","Date","objeto","data","quantidade","valor","catch","cb","all","obterNegociacoesDaSemana","obterNegociacoesDaSemanaAnterior","obterNegociacoesDaSemanaRetrasada","periodos","reduce","dados","periodo","concat","dado","console","log","erro","Error","negociacao","ConnectionFactory","getConnection","NegociacaoDao","conexao","dao","adiciona","listaTodos","apagaTodos","listaAtual","obterNegociacoes","filter","some","JSON","stringify","negociacaoExistente"],"mappings":"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","file":"NegociacaoService.js","sourcesContent":["class NegociacaoService {\r\n\r\n  constructor() {\r\n    this._http = new HttpService();\r\n  }\r\n  /*\r\n  Aplicando padrão de projeto chamado Promessa (Promise, em inglês).\r\n  O ES6 suporta a promise nativamente, então, o método deverá retornar\r\n  uma Promise(), que receberá dois parâmetros ( resolve e reject).\r\n\r\n  Em que momento sabemos que os dados são retornados?\r\n  O resolve passará diretamente o resultado de JSON.parse().\r\n  Nós passamos direto para o resolve o resultado que será disponibilizado para\r\n  a função then.\r\n  E se tivermos algum tipo de erro, chamaremos a função reject().\r\n  O que está no resolve, pegaremos dentro do método then() do arquivo\r\n  NegociacaoController.js e o erro passado para o reject, pegaremos no catch.\r\n  */\r\n  obterNegociacoesDaSemana() {\r\n    return new Promise((resolve, reject) => {\r\n      this._http.get('negociacoes/semana')\r\n      .then(negociacoes => resolve(negociacoes.map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor))))\r\n      .catch(erro => reject('Não foi possível obter as negociações da semana'))\r\n    });\r\n  }\r\n\r\n\r\n  obterNegociacoesDaSemanaAnterior(cb) {\r\n    return new Promise((resolve, reject) => {\r\n      this._http.get('negociacoes/anterior')\r\n      .then(negociacoes => resolve(negociacoes.map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor))))\r\n      .catch(erro => reject('Não foi possível obter as negociações da semana anterior'))\r\n    });\r\n  }\r\n\r\n  obterNegociacoesDaSemanaRetrasada(cb) {\r\n    return new Promise((resolve, reject) => {\r\n      this._http.get('negociacoes/retrasada')\r\n      .then(negociacoes => resolve(negociacoes.map(objeto => new Negociacao(new Date(objeto.data), objeto.quantidade, objeto.valor))))\r\n      .catch(erro => reject('Não foi possível obter as negociações da semana retrasada'))\r\n    });\r\n  }\r\n\r\n  /*\r\n  A promise possui um recurso com o qual temos uma sequência de operações\r\n  assíncronas, que será executada em uma determinada ordem.\r\n\r\n  Uma maneira de executarmos todas as promises em ordem e obtermos todos\r\n  os resultado de uma vez só é usar a função Promise.all, que receberá\r\n  um array com as promises.\r\n\r\n  Pedimos para que o Promise.all() resolvesse todas as promises na ordem\r\n  indicada.\r\n  Iremos obter os dados da Promise com o then().\r\n  Caso ocorra um erro, trataremos com o catch().\r\n  E se der uma mensagem de erro específica de obterNegociacoesDaSemana(),\r\n  o catch() será chamado - sem precisar ser chamado diversas vezes.\r\n\r\n  A grande vantagem da função Promise.all() é que todas as promises do\r\n  array serão exibidos na sequência e o resultado estará em negociacoes,\r\n  e em caso de erro, ele será capturado uma única vez.\r\n  No entanto, a negociacao retornada não é equivalente à lista de\r\n  negociações, mas sim, cada posição do array será uma lista de negociações.\r\n  Ex.: [arrayDeNegociacoes, arrayDeNegociacoes, arrayDeNegociacoes].\r\n\r\n  Antes de chegarmos até o forEach() para iterar cada negociação,\r\n  executaremos uma transformação do array que possui outros três dentro\r\n  de si.\r\n  Com o reduce(), criaremos um array que contem apenas um elemento,\r\n  contendo todos as negociações.\r\n  Nós faremos flatten - achatar - o array.\r\n\r\n  No fim, o reduce devolverá uma única lista cheia de negociações e o\r\n  forEach() será executado sem problemas.\r\n  */\r\n  obterNegociacoes() {\r\n\r\n    return Promise.all([\r\n      this.obterNegociacoesDaSemana(),\r\n      this.obterNegociacoesDaSemanaAnterior(),\r\n      this.obterNegociacoesDaSemanaRetrasada()\r\n    ]).then(periodos => {\r\n\r\n      let negociacoes = periodos\r\n      .reduce((dados, periodo) => dados.concat(periodo), [])\r\n      .map(dado => new Negociacao(new Date(dado.data), dado.quantidade, dado.valor));\r\n\r\n      return negociacoes;\r\n    }).catch(erro => {\r\n      console.log(erro);\r\n      throw new Error(erro);\r\n    });\r\n\r\n  }\r\n\r\n\r\n  cadastra(negociacao) {\r\n    return ConnectionFactory\r\n    .getConnection()\r\n    .then(conexao => new NegociacaoDao(conexao))\r\n    .then(dao => dao.adiciona(negociacao))\r\n    .then(() => 'Negociação cadastrada com sucesso')\r\n    .catch(erro => {\r\n      console.log(erro);\r\n      throw new Error(\"Não foi possível adicionar a negociação\")\r\n    });\r\n  }\r\n\r\n  lista() {\r\n\r\n    return ConnectionFactory\r\n      .getConnection()\r\n      .then(conexao => new NegociacaoDao(conexao))\r\n      .then(dao => dao.listaTodos())\r\n      .catch(erro => {\r\n        console.log(erro);\r\n        throw new Error('Não foi possível obter as negociações')\r\n      });\r\n  }\r\n\r\n  apaga() {\r\n\r\n    return ConnectionFactory\r\n      .getConnection()\r\n      .then(conexao => new NegociacaoDao(conexao))\r\n      .then(dao => dao.apagaTodos())\r\n      .then(() => 'Negociações apagadas com sucesso')\r\n      .catch(erro => {\r\n        console.log(erro);\r\n        throw new Error('Não foi possível apagar as negociações')\r\n      });\r\n  }\r\n\r\n  /*\r\n  Para evitar que a importação informe na tela as mesmas negociações que já\r\n  foram impotadas, nós utilizaremos o método some().\r\n  Todo array possui a função some(), com ela identificamos se o item buscado\r\n  faz parte da lista, varrendo cada um deles de forma semelhante a um forEach().\r\n\r\n  A função some() vai varrer cada item da lista verificando se os elementos\r\n  são iguais ao critério estabelecido.\r\n  Enquanto o item for diferente, ele seguirá para o próximo.\r\n  Quando o elemento for equivalente ao critério, a lista retornará TRUE e não\r\n  seguirá iterando no array até o fim.\r\n  Basta encontrar um item que seja correspondente ao critério para que o\r\n  retorno de some() seja \"verdadeiro\".\r\n  No entanto, quando buscamos um elemento que não existe, o retorno será \"falso\".\r\n\r\n  Contudo, nossa validação deve ser \"invertida\". Caso encontre algum elemento,\r\n  deve retornar falso e vice-versa. Pois, somente aqueles que não estão\r\n  sendo exibidos na tela é que podem passar para a próxima etapa.\r\n  Por isso estamos usando \"!\".\r\n\r\n  E estamos usando a comparação com stringify() pois negociação é um objeto.\r\n  A função stringify() converterá um objeto em string e por isso conseguimos\r\n  verificar se uma negociação é igual a outra.\r\n\r\n  Para verificar que realmente somente as novas segociações são listadas quando\r\n  apertado novamente o botão IMPORTAR, fazer o seguinte:\r\n  Acessar http://localhost:3000 e importar todas as negociações;\r\n  Abrir nova aba, acessar http://localhost:3000/post.html e incluir uma negociação;\r\n  Depois, retornar a aba que está aberto o endereço http://localhost:3000,\r\n  e apertar para importar de novo.\r\n  */\r\n  importa(listaAtual) {\r\n    return this.obterNegociacoes()\r\n      .then(negociacoes =>\r\n      // Somente vamos manter na lista de negociacoes os itens que não estão na tela\r\n        negociacoes.filter(negociacao =>\r\n          !listaAtual.some(negociacaoExistente => JSON.stringify(negociacao) == JSON.stringify(negociacaoExistente)))\r\n      ).catch(erro => {\r\n        console.log(erro);\r\n        throw new Error(\"Não foi possível importar as negociações\");\r\n      });\r\n  }\r\n}\r\n"]}